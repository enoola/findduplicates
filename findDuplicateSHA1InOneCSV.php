#!/usr/bin/php
<?Php

/*
 * will find duplicate in one file.
*/
//format of the file :
//filename|SHA1

error_reporting(E_ALL | E_STRICT);

setlocale(LC_ALL, 'fr_FR.utf8');

define ('NEW_LINE', "\r\n");

//for a more understandable code some define
define ('IDX_FILENAME',0);
define ('IDX_SHA1',1);

/*inputCSVFilename looks like this :
filename|SHA1
/volume4/Videos/Films/Historique/Argo_2012/Sample/sample-argo.dvdrip.xvid-cocain.avi|47961648c1d4a4de1c0c491eceb88b41f41496b1
/volume4/Videos/Films/Historique/Argo_2012/Argo.DVDRip.XviD.CD1-COCAIN.avi|a4f2ba0b2e0faf4644b78c019a3df9493cb790e0
/volume4/Videos/Films/Historique/Argo_2012/Argo.DVDRip.XviD.CD2-COCAIN.avi|db0851a6b4383fdfdb0e097cd4fc6976957eba27
*/

$paramExpected = __FILE__ .  ' : <CSVFileToRead> <CSVFileToPutInformationIn.csv> [CSV_Separator:|_MySeparator_|]' . NEW_LINE;
$help = "this tool is intend to find duplicates in a file generated by the script 'putFileSHA1InCSVFile.php',
this tool is intended to be used as below
$paramExpected
<CSVFileToRead> : the file generated by putFileSHA1InCSVFile.php, containing filenames, and associated SHA1
<CSVFileToPutInformationIn.csv> : the file to put duplicates in
Optionnal <CSV_Separator> : a sepeator for each column
Output will look like : 
DuplicatedSHA1|_MySeparator|filename
DuplicatedSHA1|_MySeparator|filenamedup2
DuplicatedSHA1|_MySeparator|filenamedup3
";
		
//now we want to know which folder to analyse
if ( ( $argc ==1 ) || ($argc >= 2 && ( strncmp($argv[1], '-h',2) == 0) || (strncmp($argv[1], '--help',6) == 0 )))
{
	die ($help);
}

if (($argc < 3) || ($argc > 4) )
{
	echo __FILE__ . ' : not enough or too much parameters'. NEW_LINE;
	die ($paramExpected); 
}
//does our input file exists and is readable ?
if (!is_file($argv[1]) || !is_readable($argv[1]))
{
	echo __FILE__ . " : ERROR : input file : '".$argv[1]."' isn't a file or isn't readable." . NEW_LINE;
	die ($paramExpected);
}
//output file shall not exists
if (file_exists($argv[2]))
{
	echo __FILE__ . " : ERROR : output file : '".$argv[2]."' already exists" . NEW_LINE;
	die ($paramExpected);
}

$szSeparator = '|_MySeparator_|';
if ($argc ==4)
	$szSeparator = $argv[4];


$inputCSVFilename = $argv[1];
$outputFile = $argv[2];
//die($o);

//echo '=---->'.NEW_LINE;
//if (!file_exists($inputCSVFilename) or !is_readable($inputCSVFilename))
//	die(__FILE__ . ' ERROR : unable to find or read file : "'.$inputCSVFilename.'"' . NEW_LINE);

//read the inputfile
$arCSVWellFormatted = getCSVFileContent($inputCSVFilename, $szSeparator);
//seek dups
$arWithDuplicates = getDuplicatesInArray($arCSVWellFormatted);
//put this in form.
//$arSum = getSummaryDuplicatesInArray($arWithDuplicates,$szSeparator);
//write it if they are entries 
//print_r($arWithDuplicates);

if (count($arWithDuplicates) > 0)
{
	$countDupFiles =0;
	foreach ($arWithDuplicates as $OneEntry)
		$countDupFiles += count($OneEntry[IDX_FILENAME]);
	
	echo 'number Of Entry : '.count($arCSVWellFormatted).NEW_LINE;
	echo "number Of Duplicated (SHA1), can hide more file: ". count($arWithDuplicates). NEW_LINE;
	echo "number Of Duplicated files : ". $countDupFiles. NEW_LINE;
	$szToWrite = 'SHA1' . $szSeparator . 'Duplicated Filename' . NEW_LINE;
	if (! writeInFile($outputFile, $szToWrite) )
	{
			die (__LINE__ . ' an error occured while trying to open/write (in) CSV File.' . NEW_LINE);
	}
	writeSummaryDuplicatesInArray($arWithDuplicates, $outputFile, $szSeparator);
	
}
else
	echo "no duplicates found in : '".$inputCSVFilename."', so output file '".$outputFile."' not created." . NEW_LINE;


//print_r($arSum);
function getDuplicatesInArray ($arCSVWellFormatted)
	//that's the hugly part
{
	$indexi = 0;
	$indexj = 0;
	$indexDup = 0;
	$numberOfEntry = count($arCSVWellFormatted);
	$arWithDuplicates = array();
	$arKeyAlreadyFetchedAndMatch = array();

	for ($indexi = 0; $indexi < $numberOfEntry; $indexi++)
	{
		$indexj = 0;
		$oneSHA1 = $arCSVWellFormatted[$indexi][IDX_SHA1];
		//for ($indexj = 0; $indexj < $numberOfEntry; $indexj++)
		for ($indexj = ($indexi+1); $indexj < $numberOfEntry; $indexj++)
		{
			//if (we are not comparing to ourselves) and (if hasn't already been searched for)			
			//if (array_search($indexj, $arKeyAlreadyFetchedAndMatch) === FALSE)
			//if (in_array($indexj, $arKeyAlreadyFetchedAndMatch) === FALSE)
			if (in_array($indexj, $arKeyAlreadyFetchedAndMatch) === FALSE)
			{
				if (strcmp ( $arCSVWellFormatted[$indexi][IDX_SHA1], $arCSVWellFormatted[$indexj][IDX_SHA1] ) == 0 )
				{
					//echo 'FOUND indexi='.$indexi .'__indexj='.$indexj . NEW_LINE;
					//echo 'arCSVWellFormatted[indexi='.$indexi .']=' .$arCSVWellFormatted[$indexi][IDX_FILENAME] . NEW_LINE;
					//echo 'arCSVWellFormatted[indexj='.$indexj .']=' . $arCSVWellFormatted[$indexj][IDX_FILENAME] . NEW_LINE;
					
					$arKeyAlreadyFetchedAndMatch[] = $indexj;
					//if the key doesn't exists in our array to store duplicates we do few things
					if (!array_key_exists($arCSVWellFormatted[$indexi][IDX_SHA1], $arWithDuplicates))
					{
						//first we create a fresh new entry for this SHA1 (index being the SHA1 :) )
						$arWithDuplicates[ $arCSVWellFormatted[$indexi][IDX_SHA1] ] = array();
						//do not forget the below in order to keep our index.
						$arWithDuplicates[$arCSVWellFormatted[$indexi][IDX_SHA1]][] = $arCSVWellFormatted[$indexi][IDX_FILENAME];
						//then we add the key to our array which stores already fetch and matched KEYS
						$arKeyAlreadyFetchedAndMatch[] = $indexj;
						
					}
					//finally we add the entry to our array containing duplicates
					$arWithDuplicates[$arCSVWellFormatted[$indexi][IDX_SHA1]][] = $arCSVWellFormatted[$indexj][IDX_FILENAME];
				}
			}
		}	
	}
	return ( $arWithDuplicates );
}


//arCSVWellFormatted : an array containing filename and sha1, array ('linenumber'=>array('0'=>filename, '1'=>SHA1))
//return an array with duplicated filenames 'SHA1' => filename1, filename2
function getDuplicatesInArray2 ($arCSVWellFormatted)
	//that's the hugly part
{
	$indexi = 0;
	$indexj = 0;
	$indexDup = 0;
	$numberOfEntry = count($arCSVWellFormatted);
	echo 'numberOfEntry'.$numberOfEntry.NEW_LINE;
	$arWithDuplicates = array();
	$arKeyAlreadyFetchedAndMatch = array();

	for ($indexi = 0; $indexi < $numberOfEntry; $indexi++)
	{
		$indexj = 0;
		$oneSHA1 = $arCSVWellFormatted[$indexi][IDX_SHA1];
		for ($indexj = 0; $indexj < $numberOfEntry; $indexj++)
		{
			//if (we are not comparing to ourselves) and (if hasn't already been searched for)			
			if ($indexi != $indexj && (array_search($indexj, $arKeyAlreadyFetchedAndMatch) === FALSE))
			{
				if (strcmp ( $arCSVWellFormatted[$indexi][IDX_SHA1], $arCSVWellFormatted[$indexj][IDX_SHA1] ) == 0 )
				{
					//echo 'FOUND indexi='.$indexi .'__indexj='.$indexj . NEW_LINE;
					//echo 'arCSVWellFormatted[indexi='.$indexi .']=' .$arCSVWellFormatted[$indexi][IDX_FILENAME] . NEW_LINE;
					//echo 'arCSVWellFormatted[indexj='.$indexj .']=' . $arCSVWellFormatted[$indexj][IDX_FILENAME] . NEW_LINE;
					
					$arKeyAlreadyFetchedAndMatch[] = $indexj;
					//if the key doesn't exists in our array to store duplicates we do few things
					if (!array_key_exists($arCSVWellFormatted[$indexi][IDX_SHA1], $arWithDuplicates))
					{
						//first we create a fresh new entry for this SHA1 (index being the SHA1 :) )
						$arWithDuplicates[ $arCSVWellFormatted[$indexi][IDX_SHA1] ] = array();
						//then we add the key to our array which stores already fetch and matched KEYS
						$arKeyAlreadyFetchedAndMatch[] = $indexj;
					}
					//finally we add the entry to our array containing duplicates
					$arWithDuplicates[$arCSVWellFormatted[$indexi][IDX_SHA1]][] = $arCSVWellFormatted[$indexj][IDX_FILENAME];
				}
			}
		}	
	}
	return ( $arWithDuplicates );
}

function writeSummaryDuplicatesInArray( $arWithDuplicates, $outputFile, $szSeparator )
{
	foreach ( $arWithDuplicates as $sha1 => $arFilename)
	{
		foreach ($arFilename as $szFilename)
		{
			$szToWrite = $sha1 . $szSeparator . $szFilename . NEW_LINE;
		
			if (! writeInFile($outputFile, $szToWrite) )
				die (__LINE__ . ' an error occured while trying to open/write (in) CSV File.' . NEW_LINE);
		}	
	}
}


//return an array ('linenumber'=>array('0'=>filename, '1'=>SHA1))
//filename : the filename
function getCSVFileContent($filename, $szSeparator)
{
	echo __FUNCTION__ . NEW_LINE;
	$arFileContent = file($filename, FILE_IGNORE_NEW_LINES);
	$arFormatted = array();
	
	$index = 0;
	$numberOfLine = count($arFileContent);
	echo 'num of line:'.$numberOfLine.NEW_LINE;
	for ($i = 0; $i < $numberOfLine; $i++)
	{
		//$OneLine = $arFileContent[$i];
		//to gain some memory we shift the entry from the array
		$OneLine = array_shift($arFileContent);
		
		$arFormatted[$i] = explode($szSeparator, $OneLine);
	}
	
	return ( $arFormatted );
}

function writeInFile($outputFile, $szToWrite)
{
	$fd = fopen($outputFile,'a');
	if ($fd == FALSE )
		return ( FALSE );
		
	$lenToWrite = strlen($szToWrite);
	$ret = fwrite( $fd, $szToWrite, $lenToWrite);
	if ($fd === FALSE)
	{
		fclose($fd);
		return ( FALSE );
	}
	
	fclose($fd);
	return ( TRUE );
}



?>



